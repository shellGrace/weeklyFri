---
date: 2023/09/01
---

<img src="https://i.imgs.ovh/i/2023/08/30/64eebb94eeef7.png" width="800" />

<small>封面图来源于2020年RTE互联网大会，作为主办方开发者带着自己的作品参展还是很有成就感的。</small>

**自己写的demo**
<img src="https://i.imgs.ovh/i/2023/08/30/64eebb8ab04d1.png" width="800" />

### 技术分享

# 闭包
*是一个函数以及其捆绑的周边环境状态（lexical environment，词法环境）的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在 JavaScript 中，闭包会随着函数的创建而被同时创建。*

词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部作用域的变量

```javascript
function makeFunc() {
  var name = "Mozilla";
  function displayName() {
    alert(name);
  }
  return displayName;
}

var myFunc = makeFunc();
myFunc();
```

## 闭包的应用

### 节流
```javascript
function throttle(fun, delay) {
  let last = 0;
  return function(...args) {
    const now = +new Date();
    if (last - now >= delay) {
      fun.apply(this, args);
      last = now;
    }
  }
}
```

### 防抖
```javascript
debounce(fun, delay) {
  let timer = null;
  return function() {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fun.apply(this, arguments)
    }, delay)
  }
}
```


# Promise

## 实现原理
通过状态的变化来表示异步操作的结果
当异步操作完成时，可以调用 resolve 来将 Promise 的状态标记为 fulfilled，或者调用 reject 将其状态标记为 rejected。
通过链式调用 .then() 方法来注册回调函数，用于在 Promise 状态变为 fulfilled 时执行，或者通过 .catch() 方法来注册回调函数，用于在状态变为 rejected 时执行
*异步方法不会立即返回最终值，而是返回一个 promise，以便在将来的某个时间点提供该值。*

## 回调地狱
回调地狱是指在处理多个嵌套的异步操作时，代码变得难以理解、维护和扩展的情况。

### 处理回调地狱
Promise：可以形成一个线性的链式调用，避免了嵌套的回调。catch 捕获错误
async/await：使用 async 关键字声明函数，然后在内部使用 await 关键字等待异步操作的结果

## async/await 
将异步操作的执行流程暂停，直到 Promise 完成，然后再继续执行。避免回调地狱
async 声明一个使用 async 关键字的函数，它会返回一个 Promise 对象。
await 阻塞函数的执行，直到所等待的 Promise 被 resolved（或 rejected）。

当 await 关键字在 async 函数内部使用时，它会阻塞函数的执行，直到所等待的 Promise 被 resolved（或 rejected）。在等待期间，await 表达式的值将是 Promise 的 resolved 值

### Promise API
Promise.all()  // 所有都成功执行回调
Promise.race() //  返回第一个敲定（无论是兑现还是拒绝）
Promise.any() //  忽略所有被拒绝的 Promise，直到第一个被兑现的 Promise。

封装尚未支持 Promise 的基于回调的 API

```javascript
const promise1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('foo');
  }, 300);
});
promise1.then((value) => {
  console.log(value);
  // Expected output: "foo"
});
console.log(promise1);
// Expected output: [object Promise]

```

### 状态
待定（pending）已兑现（fulfilled）已拒绝（rejected）

## 手写 Promise.all()
在所有输入的 Promise 都变为 resolved 状态时被 resolved，在其中一个 Promise 变为 rejected 状态时被 rejected。
```javascript
function customPromiseAll(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Input is not an array'));
    }
    
    let resolvedCount = 0;
    const results = new Array(promises.length);
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(result => {
          results[index] = result;
          resolvedCount++;
          
          if (resolvedCount === promises.length) {
            resolve(results);
          }
        })
        .catch(error => {
          reject(error);
        });
    });
  });
}

// 使用示例
const promise1 = Promise.resolve(1);
const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => resolve(2), 1000);
});
const promise3 = Promise.resolve(3);

customPromiseAll([promise1, promise2, promise3])
  .then(results => {
    console.log('Resolved values:', results); // [1, 2, 3]
  })
  .catch(error => {
    console.error('Error:', error);
  });
```
